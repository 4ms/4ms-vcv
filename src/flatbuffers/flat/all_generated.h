// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_H_
#define FLATBUFFERS_GENERATED_ALL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct Heartbeat;

struct PatchInfo;
struct PatchInfoBuilder;

struct DirInfo;
struct DirInfoBuilder;

struct Patches;
struct PatchesBuilder;

struct UploadPatch;
struct UploadPatchBuilder;

struct Result;
struct ResultBuilder;

struct Message;
struct MessageBuilder;

enum AnyMessage : uint8_t {
  AnyMessage_NONE = 0,
  AnyMessage_Heartbeat = 1,
  AnyMessage_UploadPatch = 2,
  AnyMessage_Patches = 3,
  AnyMessage_Result = 4,
  AnyMessage_MIN = AnyMessage_NONE,
  AnyMessage_MAX = AnyMessage_Result
};

inline const AnyMessage (&EnumValuesAnyMessage())[5] {
  static const AnyMessage values[] = {
    AnyMessage_NONE,
    AnyMessage_Heartbeat,
    AnyMessage_UploadPatch,
    AnyMessage_Patches,
    AnyMessage_Result
  };
  return values;
}

inline const char * const *EnumNamesAnyMessage() {
  static const char * const names[6] = {
    "NONE",
    "Heartbeat",
    "UploadPatch",
    "Patches",
    "Result",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyMessage(AnyMessage e) {
  if (::flatbuffers::IsOutRange(e, AnyMessage_NONE, AnyMessage_Result)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyMessage()[index];
}

template<typename T> struct AnyMessageTraits {
  static const AnyMessage enum_value = AnyMessage_NONE;
};

template<> struct AnyMessageTraits<Heartbeat> {
  static const AnyMessage enum_value = AnyMessage_Heartbeat;
};

template<> struct AnyMessageTraits<UploadPatch> {
  static const AnyMessage enum_value = AnyMessage_UploadPatch;
};

template<> struct AnyMessageTraits<Patches> {
  static const AnyMessage enum_value = AnyMessage_Patches;
};

template<> struct AnyMessageTraits<Result> {
  static const AnyMessage enum_value = AnyMessage_Result;
};

bool VerifyAnyMessage(::flatbuffers::Verifier &verifier, const void *obj, AnyMessage type);
bool VerifyAnyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Heartbeat FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t _dummy_;

 public:
  Heartbeat()
      : _dummy_(0) {
  }
  Heartbeat(bool __dummy)
      : _dummy_(::flatbuffers::EndianScalar(static_cast<uint8_t>(__dummy))) {
  }
  bool _dummy() const {
    return ::flatbuffers::EndianScalar(_dummy_) != 0;
  }
  void mutate__dummy(bool __dummy) {
    ::flatbuffers::WriteScalar(&_dummy_, static_cast<uint8_t>(__dummy));
  }
};
FLATBUFFERS_STRUCT_END(Heartbeat, 1);

struct PatchInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PatchInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FILENAME = 6,
    VT_SIZE = 8,
    VT_TIMESTAMP = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  ::flatbuffers::String *mutable_filename() {
    return GetPointer<::flatbuffers::String *>(VT_FILENAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  uint32_t timestamp() const {
    return GetField<uint32_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint32_t _timestamp = 0) {
    return SetField<uint32_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_TIMESTAMP, 4) &&
           verifier.EndTable();
  }
};

struct PatchInfoBuilder {
  typedef PatchInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PatchInfo::VT_NAME, name);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(PatchInfo::VT_FILENAME, filename);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(PatchInfo::VT_SIZE, size, 0);
  }
  void add_timestamp(uint32_t timestamp) {
    fbb_.AddElement<uint32_t>(PatchInfo::VT_TIMESTAMP, timestamp, 0);
  }
  explicit PatchInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PatchInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PatchInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PatchInfo> CreatePatchInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    uint32_t size = 0,
    uint32_t timestamp = 0) {
  PatchInfoBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_size(size);
  builder_.add_filename(filename);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PatchInfo> CreatePatchInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *filename = nullptr,
    uint32_t size = 0,
    uint32_t timestamp = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return CreatePatchInfo(
      _fbb,
      name__,
      filename__,
      size,
      timestamp);
}

struct DirInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DirInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SUBDIRS = 6,
    VT_FILES = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DirInfo>> *subdirs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DirInfo>> *>(VT_SUBDIRS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<DirInfo>> *mutable_subdirs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<DirInfo>> *>(VT_SUBDIRS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<PatchInfo>> *files() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PatchInfo>> *>(VT_FILES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<PatchInfo>> *mutable_files() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<PatchInfo>> *>(VT_FILES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SUBDIRS) &&
           verifier.VerifyVector(subdirs()) &&
           verifier.VerifyVectorOfTables(subdirs()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           verifier.EndTable();
  }
};

struct DirInfoBuilder {
  typedef DirInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DirInfo::VT_NAME, name);
  }
  void add_subdirs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DirInfo>>> subdirs) {
    fbb_.AddOffset(DirInfo::VT_SUBDIRS, subdirs);
  }
  void add_files(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PatchInfo>>> files) {
    fbb_.AddOffset(DirInfo::VT_FILES, files);
  }
  explicit DirInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DirInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DirInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DirInfo> CreateDirInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DirInfo>>> subdirs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PatchInfo>>> files = 0) {
  DirInfoBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_subdirs(subdirs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DirInfo> CreateDirInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<DirInfo>> *subdirs = nullptr,
    const std::vector<::flatbuffers::Offset<PatchInfo>> *files = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto subdirs__ = subdirs ? _fbb.CreateVector<::flatbuffers::Offset<DirInfo>>(*subdirs) : 0;
  auto files__ = files ? _fbb.CreateVector<::flatbuffers::Offset<PatchInfo>>(*files) : 0;
  return CreateDirInfo(
      _fbb,
      name__,
      subdirs__,
      files__);
}

struct Patches FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PatchesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USB = 4,
    VT_FLASH = 6,
    VT_SDCARD = 8
  };
  const DirInfo *usb() const {
    return GetPointer<const DirInfo *>(VT_USB);
  }
  DirInfo *mutable_usb() {
    return GetPointer<DirInfo *>(VT_USB);
  }
  const DirInfo *flash() const {
    return GetPointer<const DirInfo *>(VT_FLASH);
  }
  DirInfo *mutable_flash() {
    return GetPointer<DirInfo *>(VT_FLASH);
  }
  const DirInfo *sdcard() const {
    return GetPointer<const DirInfo *>(VT_SDCARD);
  }
  DirInfo *mutable_sdcard() {
    return GetPointer<DirInfo *>(VT_SDCARD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USB) &&
           verifier.VerifyTable(usb()) &&
           VerifyOffset(verifier, VT_FLASH) &&
           verifier.VerifyTable(flash()) &&
           VerifyOffset(verifier, VT_SDCARD) &&
           verifier.VerifyTable(sdcard()) &&
           verifier.EndTable();
  }
};

struct PatchesBuilder {
  typedef Patches Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_usb(::flatbuffers::Offset<DirInfo> usb) {
    fbb_.AddOffset(Patches::VT_USB, usb);
  }
  void add_flash(::flatbuffers::Offset<DirInfo> flash) {
    fbb_.AddOffset(Patches::VT_FLASH, flash);
  }
  void add_sdcard(::flatbuffers::Offset<DirInfo> sdcard) {
    fbb_.AddOffset(Patches::VT_SDCARD, sdcard);
  }
  explicit PatchesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Patches> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Patches>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Patches> CreatePatches(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DirInfo> usb = 0,
    ::flatbuffers::Offset<DirInfo> flash = 0,
    ::flatbuffers::Offset<DirInfo> sdcard = 0) {
  PatchesBuilder builder_(_fbb);
  builder_.add_sdcard(sdcard);
  builder_.add_flash(flash);
  builder_.add_usb(usb);
  return builder_.Finish();
}

struct UploadPatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UploadPatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4,
    VT_VOLUME = 6,
    VT_FILENAME = 8
  };
  const ::flatbuffers::Vector<uint8_t> *content() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_content() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  const ::flatbuffers::String *volume() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOLUME);
  }
  ::flatbuffers::String *mutable_volume() {
    return GetPointer<::flatbuffers::String *>(VT_VOLUME);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  ::flatbuffers::String *mutable_filename() {
    return GetPointer<::flatbuffers::String *>(VT_FILENAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyOffset(verifier, VT_VOLUME) &&
           verifier.VerifyString(volume()) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           verifier.EndTable();
  }
};

struct UploadPatchBuilder {
  typedef UploadPatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content) {
    fbb_.AddOffset(UploadPatch::VT_CONTENT, content);
  }
  void add_volume(::flatbuffers::Offset<::flatbuffers::String> volume) {
    fbb_.AddOffset(UploadPatch::VT_VOLUME, volume);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(UploadPatch::VT_FILENAME, filename);
  }
  explicit UploadPatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UploadPatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UploadPatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UploadPatch> CreateUploadPatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content = 0,
    ::flatbuffers::Offset<::flatbuffers::String> volume = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0) {
  UploadPatchBuilder builder_(_fbb);
  builder_.add_filename(filename);
  builder_.add_volume(volume);
  builder_.add_content(content);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UploadPatch> CreateUploadPatchDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content = nullptr,
    const char *volume = nullptr,
    const char *filename = nullptr) {
  auto content__ = content ? _fbb.CreateVector<uint8_t>(*content) : 0;
  auto volume__ = volume ? _fbb.CreateString(volume) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return CreateUploadPatch(
      _fbb,
      content__,
      volume__,
      filename__);
}

struct Result FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success = 0) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  ::flatbuffers::String *mutable_message() {
    return GetPointer<::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResultBuilder {
  typedef Result Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(Result::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Result::VT_MESSAGE, message);
  }
  explicit ResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Result> CreateResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Result> CreateResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return CreateResult(
      _fbb,
      success,
      message__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  AnyMessage content_type() const {
    return static_cast<AnyMessage>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Heartbeat *content_as_Heartbeat() const {
    return content_type() == AnyMessage_Heartbeat ? static_cast<const Heartbeat *>(content()) : nullptr;
  }
  const UploadPatch *content_as_UploadPatch() const {
    return content_type() == AnyMessage_UploadPatch ? static_cast<const UploadPatch *>(content()) : nullptr;
  }
  const Patches *content_as_Patches() const {
    return content_type() == AnyMessage_Patches ? static_cast<const Patches *>(content()) : nullptr;
  }
  const Result *content_as_Result() const {
    return content_type() == AnyMessage_Result ? static_cast<const Result *>(content()) : nullptr;
  }
  void *mutable_content() {
    return GetPointer<void *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyAnyMessage(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Heartbeat *Message::content_as<Heartbeat>() const {
  return content_as_Heartbeat();
}

template<> inline const UploadPatch *Message::content_as<UploadPatch>() const {
  return content_as_UploadPatch();
}

template<> inline const Patches *Message::content_as<Patches>() const {
  return content_as_Patches();
}

template<> inline const Result *Message::content_as<Result>() const {
  return content_as_Result();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(AnyMessage content_type) {
    fbb_.AddElement<uint8_t>(Message::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(::flatbuffers::Offset<void> content) {
    fbb_.AddOffset(Message::VT_CONTENT, content);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    AnyMessage content_type = AnyMessage_NONE,
    ::flatbuffers::Offset<void> content = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline bool VerifyAnyMessage(::flatbuffers::Verifier &verifier, const void *obj, AnyMessage type) {
  switch (type) {
    case AnyMessage_NONE: {
      return true;
    }
    case AnyMessage_Heartbeat: {
      return verifier.VerifyField<Heartbeat>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case AnyMessage_UploadPatch: {
      auto ptr = reinterpret_cast<const UploadPatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage_Patches: {
      auto ptr = reinterpret_cast<const Patches *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage_Result: {
      auto ptr = reinterpret_cast<const Result *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyMessage(
        verifier,  values->Get(i), types->GetEnum<AnyMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Message>(buf);
}

inline const Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Message>(buf);
}

inline Message *GetMutableMessage(void *buf) {
  return ::flatbuffers::GetMutableRoot<Message>(buf);
}

inline Message *GetMutableSizePrefixedMessage(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Message> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_ALL_H_
